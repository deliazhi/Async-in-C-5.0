#概述

让我们从了解C#5.0中的async特性开始吧。

###异步编程
当开始一个耗时操作时，与阻塞代码坐在那什么也做相对的，异步代码无需等待。

耗时操作包括：
+ 网络请求
+ 磁盘读取
+ 延时操作

区别在于运行代码的线程。在广泛使用的编程语言中，代码运行在操作系统的线程中。当发生耗时操作时，线程可以继续去做其他的事情，那么你的代码就是异步的，否则代码就是阻塞的。

> 当然，还有第三种处理耗时操作的方式——轮询，就是重复询问耗时操作是否完成。尽管在这个过程中也可以处理一些简单的操作，但它通常不是一个好的解决方案。

也许你已经在工作中用到了异步编程。比如你开启了一个新线程或者使用了线程池，这样线程就可以去处理其他的事情。再比如，你编写了一个web页面，web服务器的线程无需等待用户输入就可以访问其他页面。试想，如果采用控制台应用程序的设计模式，用Console.ReadLine()去接受用户的输入，将会是一种多么糟糕的设计。

异步编程的难点在于，这个耗时操作什么时候结束，以便继续执行下一步操作。而在阻塞型代码里，这是显而易见的，你只需要在长耗时代码的下一行写你的后续代码即可。而在一步代码里，这样就不起作用了，因为几乎可以肯定的是，你的下一行代码会在你异步操作完成之前就运行了。

为了解决这个问题，我们发明了一系列运行后台操作完成之后的代码模式：
+ 将代码写入到后台操作的主体函数之后
+ 注册一个耗时操作结束时可以触发的事件
+ 在耗时操作完成后传递一个委托或者lambda表达式（回调）

如果下一个操作需要在特定的线程上执行（例如WinForms或者WPF的UI线程），你还需要处理那个线程上的操作排序问题，这实在太复杂了。

### 异步编程的好处
异步编程释放了最开始执行的线程，这有许多好处,其一，线程占用更少的资源总是好的；其二，一个线程可以处理一件事情，就像UI线程，如果你没有及时释放线程，你的应用程序会出现未响应状态。我们将会在下一章详细讨论这些好处。

异步编程让我激动的最大原因是，它让我们享受到计算机并行计算带来的好处。异步编程让我们可以用一种更细粒度的并行性去构建自己的应用程序，而无需编写晦涩难懂的复杂代码。第十章将会详细介绍。

### 什么是异步编程
在C#5.0中，微软的编译团队新增了一个强大的特性。
它以两个关键词出现：
+ async
+ await

它还依赖.NET Framework4.5的其他一些附件和变化来发挥作用。

> Async是C#编译器的一个特性，不能被封装成一个类库。它对你的源代码起到了一个转换的作用，就如同C#之前版本中的Lambda和迭代器一样。

这个特性通过免除早期C#所需的复杂模式使异步编程变得非常简单，有了它，我们可以用一种异步风格编写整个项目了。

### Async做了什么
async特性是一种简单易读的异步行为，表明了耗时操作完成之后要继续执行的代码。

异步方法经过编译器的转换，让一步代码看上去和阻塞代码别无二致。这有一段简单的下单网页的阻塞代码：
```C#
private void DumpWebPage(string uri)
{
    WebClient webClient = new WebClient();
    string page = webClient.DownloadString(uri);
    Console.WriteLine(page);
} 
```
这里还有一段实现相同功能的async代码：
```C#
private async void DumpWebPageAsync(string uri)
{
    WebClient webClient = new WebClient();
    string page = await webClient.DownloadStringTaskAsync(uri);
    Console.WriteLine(page);
}
```
它们看上去极为相似，但实际上，它们有着很大的不同。

被标记为async的方法需要有await关键字的方法，并且为了遵循惯例，我们通常会在这个方法名后面添加Async后缀。

有趣的是await关键字。当编译器遇到它时，编译器会将方法分开。事实上编译器所做的事情是相当复杂的，所以我将介绍一个便于理解的假设。

1. 所有await之后的方法都将被分离成另一个单独的方法。
2. 我们使用一个名为DownloadStringTaskAsync的方法来代替DownloadString方法，这两个方法功能相同，只不过DownloadStringTaskAsync是异步的。
3. 这意味着当这个操作完成时，我们可以继续执行一个新的方法。稍后我将告诉你如何用一些神奇的方式将它实现。
4. 当下载完成，它将返回给我们一个可用的字符串，以便输出到控制台

```C#
private void DumpWebPageAsync(string uri)
{
    WebClient webClient = new WebClient();
    webClient.DownloadStringTaskAsync(uri) <- magic(SecondHalf);
}
private void SecondHalf(string awaitedResult)
{
    string page = awaitedResult;
    Console.WriteLine(page);
} 
```
运行这段代码时，调用线程发生了什么？当运行到DownloadStringTaskAsync时，开始下载，但不是在当前线程进行下载。在当前线程中，我们已经到达了方法的结尾并return了。当前线程下一步要做什么取决于调用者。如果是一个UI线程，它将返回执行用户操作。否则，它的资源将被释放。这也意味着我已经在写异步代码啦！

### 异步编程并不能解决所有问题

async特性被设计得尽可能像阻塞代码。我们可以通过异步调用的方式将耗时操作或者远程操作处理得就像本地操作一样快。

然而，这样的设计并不会为了让你忘记后台操作和回调的发生。当你使用async的时候，还需要小心很多事情，包括：
+ 异常以及异常处理
+ 方法的返回值
+ 线程以及上下文
+ 性能

如果不能真正理解发生了什么，你的应用程序很可能以意想不到的方式挂掉，而你也无法理解错误信息或者通过调试去修复它。