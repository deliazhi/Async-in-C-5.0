# 为什么需要异步编程
异步编程很重要也很有用的原因有很多，主要看你开发的是什么类型的应用程序。有些好处随处可见，但有些可能存在于你从未开发过的应用程序中。阅读本章作为背景知识将会帮助你理解正本书的内容。

### 桌面应用程序
桌面应用程序有一个主要的性能要求，就是需要给用户可感受到的响应。HCI研究表明，用户不会关注响应慢的应用程序，所以在接口做出响应时最好有一个动态的进度条。

当应用程序没反应时人们会变得沮丧。没反应通常是因为在一个耗时操作中，程序无法给用户的输入做出及时的响应并返回结果。原因包括计算缓存或者是IO操作，例如网络请求。

你所使用的C#UI框架都是单个UI线程进行操作的。包括：
+ WinForms
+ WPF
+ Silverlight

UI线程是唯一可以控制特定窗口内容的。也是唯一验证用户行为并返回内容给用户的线程。如果这个线程繁忙或者哪怕是被阻塞了几十毫秒，用户也会觉得这个应用程序反应迟缓。

异步代码，哪怕是手工编写的，也意味着UI线程可以返回到它的主工作去检查用户事件的消息队列，并对它们进行响应。它还可以执行进度动画，以及最近Windows版本中的鼠标悬停动画都是给用户对于这个应用程序留下及时响应的良好印象的重要视觉提示。
> 所有常见UI框架都使用单线程的原因是为了简化同步。如果是多线程的话，为了避免一个线程在布局控件的同时，另一个线程在尝试读取按钮的宽度的冲突，你需要大量使用锁，这样反而导致性能比单线程更低。

##### 打个比方：咖啡馆
我想用一个类比来帮助我们直观地理解所涉及到的问题。如果你已经理解了，那么可以跳过此小节。

想想一下，有一家小咖啡馆给顾客提供面包作为早餐。唯一的员工就是老板自己。他非常注重客户服务，但他还没学会异步技术。

UI线程模型和咖啡馆的老板很相似。和计算机中事情必须通过一个线程去执行一样，只有咖啡馆的员工可以在咖啡馆里工作。而且只有一个员工，就好像只有一个UI线程一样。

第一个客人想要一片面包。老板取出面包并且放入烤箱，然后他就盯着烤箱运作。以致客人问他黄油在哪儿都被他忽略了，因为他被盯着烤箱阻塞了。五分钟后，面包烤好了，老板取出面包并递给客人。此时，已经排起长队，客人们对于被忽略表示很生气，这一点也不理想。

现在，让我们来教老板如何进行异步操作吧。

首先，老板要确保他的烤箱可以进行异步操作。当编写异步代码的时候，我们也需要知道耗时操作何时完成以便返回。所以，同样的，烤箱也需要有一个定时器，当面包烤好时可以响起铃声，以便通知老板。

下一步就是当烤箱运作时，老板忽略它而不是像以前那样盯着它，他应该继续去为客人提供服务。同样，我们的异步代码在遇到耗时操作时也需要返回以便UI线程可以去继续响应用户的操作。这有两个原因：
+ 可以更及时的响应用户——客人可以继续询问黄油在哪儿而不是被忽略。
+ 用户可以同时开始另一个操作——下一个客人可以开始点单。

咖啡馆老板现在可以同时服务多个客人了，只是受限于他所拥有的烤箱数量以及他去拿烤好的面包所耗费的时间。但这也带来了它特有的问题：老板发现他很难记住哪片面包是给哪个客人的。事实上，UI线程根本无法记住它返回继续执行用户事件时所等待的是哪个操作。

因此，当耗时操作开始的时候我们需要附加一个回调函数，以便提醒我们，当耗时操作完成时应该做什么。对于咖啡馆老板而言，很简单，只要在烤箱上贴上写有客人姓名的标签即可。我们也许还需要一些更复杂的东西，通常来讲，当耗时操作完成时，对于我们需要做的事情希望可以提供一个完整的说明。

有了这些，咖啡馆老板现在是完全异步的了，而且生意兴隆。客人的体验也好了很多。更少的等待时间，更快的服务响应。我希望这个类比可以帮助你理解为什么异步对于UI应用程序如此重要。
### Web应用程序的服务端代码
尽管ASP.NET的Web服务器没有像UI代码一样只有一个线程的限制，但使用异步编程依然有很多好处。耗时操作，尤其是远程数据库查询，在web应用程序的代码中非常常见。

对于处理Web请求的线程总数或者处理并发请求的总数的限制取决于你IIS的版本。如果你的请求大部分时间都在等待数据库查询，那么增加同步请求的数量来增加服务器处理的吞吐量似乎是个好主意。

当一个线程被阻塞，出于等待状态，它并不占用CPU时间。然而，不要想当然的以为它就不使用你服务器的任何资源了。事实上，线程会导致两个重要的开销，即使它们被阻塞了：
+ 内存

　　*每个托管线程在Windows上大约占用一兆字节的虚拟内存。如果是几十个线程那没问题，但如果有几百个线程就会变得很容易失控。当内存不够开始使用磁盘空间时，恢复线程将会变得十分缓慢。*
+ 调度器开销

　　*操作系统调度器的职责是确定什么时候在哪个CPU上去执行哪个线程。即使线程阻塞时，调度器也需要把阻塞的线程考虑在内，并及时判断它们是否脱离阻塞状态。这降低了上下文的切换速度，甚至拖慢整个系统。*

这两者的这些开销会加重服务器的负载，增加延迟，降低吞吐量。

记住：异步编程的主要特征就是线程在开始运行一个耗时操作时可以被释放去做其他的事情。在ASP.NET代码中，线程来自线程池，所以在耗时操作期间线程会返回到线程池，以便可以处理其他请求，这样，只需更少的线程去处理相同数量的请求。
##### 再打个比方：餐厅的厨房
web服务器和餐厅模式很类似。很多客人点餐，厨房尽快满足他们。

厨房里有许多厨师，每个厨师代表一个线程。厨师们做客人们点的菜，但每道菜需放在锅里煮一会儿，煮的过程中厨师无事可做。这就好比web请求通常都会有数据库查询操作，而这个操作是web服务器无法参与的。

在厨房的一个阻塞的实施过程中，厨师会坐在那里等着锅里的菜煮熟。为了精确的模拟一个线程，这些厨师有一份奇怪的合同，也就是他们在等待的时候不赋予报酬，因为线程被阻塞时是不占用CPU时间的。也许他们等待的时候在看报纸呢！ 

但即使厨师等待的时间我们不需要付钱，我们还是要再雇一个厨师去做我们必须要做的菜，而等待着的厨师们占用了厨房的空间，我们不能让几十个厨师占满厨房，使厨房变得难以移动，进而使每个人的工作效率变慢。

当然，如果采用异步的方式情况会变得好很多。每当菜放入锅里的时候，厨师备注一下锅里是什么菜，烹饪到哪一个步骤了，然后去找一个新的任务继续执行。当锅里的菜煮好时，任何一个厨师都可以取出来并继续这道菜的下一个烹饪步骤。

web服务器就是如此强大而高效的系统。只需要极少数的线程就可以处理以前也许需要上百个线程才能处理，甚至是导致宕机的并发请求。然而，一些web框架，比如node.js，就拒绝多线程的思想而采用单线程的方式去异步处理所有请求。它们通常可以用单线程去处理更多的请求而不是用多线程但阻塞的方式去处理请求。同样的道理，一个有条理的厨师在一个空旷的厨房里可以比上百个把时间花在绊倒对方或者读报纸的厨师们做出更多的菜。
### Silverlight，Windows Phone和Windows 8
Silverlight的设计者深知UI应用程序中异步编程的好处。所以，他们决定鼓励每一个人都去编写异步代码。他们通过移除框架里几乎所有的同步API来达到此目的，因此，web请求只存在于异步调用当中。

异步代码是会传染的。如果你调用一个异步的API，那么你的代码也会以异步的方式结束。因此，在Silverlight框架里，你必须写异步代码，因为你没有选择。当回调发生阻塞时，也许有一个等待的方法或其他通过同步的方式调用异步API的方式，但如果真这样做的话，你就失去我所说的所有优势了。

Windows Phone的Silverlight，就像它的全名一样，是一种轻量级的框架。可用的额外API在Silverlight的浏览器环境中是不安全的，例如TCP套接字。因此，只有异步API的存在鼓励你编写异步代码。如果说有什么不同的话，那就是在移动设备上使用异步代码更重要，因为资源非常稀缺。启动额外的线程可能会对电池寿命有严重的影响。

最后，尽管与Silverlight没有技术上的联系，Windows 8应用程序也采用了相同的方法，更多可用的API，但只有异步版本的，这些API可能需要超过50 ms才能完成。

### 并行代码
计算机由越来越多的内核组成，他们独立运行。程序应当能够利用这些多核的优势，但那些通过多核编写的程序无法同时写入内存，否则内存将被损坏。
> 也许我们更擅长使用一种纯粹的编程风格，即不在内存中操作状态，而是处理不可变值。这有助于利用并发，但对于另一些程序则不适合。例如用户界面程序需要知道结果状态，数据库查询的结果状态等。

标准的解决方案就是当多个内核可能访问相同内存时使用互斥锁。但这也会带来新的问题。你的代码在有了一个锁的情况下又调用了一个方法或者触发了一个事件又会产生另一个锁。通常没有必要占用两个锁，但代码不这么认为。

这是对锁的错误争用，也就是说，更多的线程在可以做一些有用的工作时却死于锁的等待。有些时候，两个线程同时在等待对方的锁时就会造成死锁。这种错误很难预测，很难复现也很难修复。

最有希望的解决方案之一是actors计算模型。这是一种每个可写的内存只能存在于一个actor的设计。使用那块内存的唯一方式就是给那个actor发送消息，从而一次只处理一个actor的请求，并返回另一条信息。这就是异步编程。寻求一个actor是一种典型的异步操作，因为在接收到返回的信息之前我们可以继续去做其他的事情。也就是说可以通过异步来实现这种并行，我们将会在第十章详细叙述。

### 一个示例
我们来看一个急需转换成异步风格的桌面UI程序。[源码](https://bitbucket.org/alexdavies74/faviconbrowser)。我建议如果可以的话把代码下载下来，然后运行程序，你会看到一个窗体，上面有一个按钮，如果你点击这个按钮，窗体上会展示一些流行网站的图标。它通过下载大多数网站都包含的favicon.ico文件实现的。

![图2-1.图标浏览运行结果](/img/Figure 2-1.png)

图2-1.图标浏览运行结果 

让我们看一看代码是怎么写的吧。最重要的部分就是下载图标并且将它添加到窗口中的WPF WrapPanel。
```C#
private void AddAFavicon(string domain)
{
    WebClient webClient = new WebClient();
    byte[] bytes = webClient.DownloadData("http://" + domain + "/favicon.ico");
    Image imageControl = MakeImageControl(bytes);
    m_WrapPanel.Children.Add(imageControl);
}                                        
```
你会发现，这个实现完全是同步的。当下载图标的时候线程会被阻塞。也许你也发现了，当你点击按钮后窗体有那么几秒钟处理无响应状态。正如你所知道的一样，当下载图标的时候UI线程出于阻塞状态，且不能返回用户事件的进行程序。

在接下来的章节中，我们将使用这个例子来演示将同步程序转换为异步程序。
